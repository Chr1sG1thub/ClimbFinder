<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climb Finder</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        #fileInput { margin: 20px 0; }
        #results { margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 5px; }
        pre { background: #f4f4f4; padding: 10px; overflow-x: auto; white-space: pre-wrap; }
        button { padding: 10px 20px; background: #007cba; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #005a87; }
        .error { color: red; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <h1>Climb Finder</h1>
    <p>Select a GPX file to parse trackpoints (lat/lon/ele) and locate climbs.</p>
    <input type="file" id="fileInput" accept=".gpx" />
    <button onclick="analyzeGPX()">Climb Finder</button>
    
    <div id="results" style="display: none;">
    </div>
    <div id="error" class="error" style="display: none;"></div>

    <script>

/**
 * COMPLETE JS IMPLEMENTATION: Perl findClimbs port with corrections/improvements.
 * Recursively detects climbs/descents in GPS profiles (GPX/Strava). Turf.js required.
 * Improvements: recursion guards, scaled distances, exact Fiets, efficient simplify.
 * Usage: findClimbs({points: gpxPoints, courseDistance: 50.2, isLoop: true})
 * Returns: [[startIdx, endIdx, {rating, gain, dist, avgGrad}], ...]
 * @turfjs: https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js
 */
function findClimbs({
  points,                  // [{lat, lon, ele}, ...] GPX points
  indices,                 // Optional pre-simplified indices
  simplifyPoints = true,   // Douglas-Peucker simplify?
  shiftCircuit = true,     // Rotate loops to ele min?
  courseDistance = 0,      // Total route km (auto if 0)
  gradientPower = 2,       // Steepness exponent (2=Fiets-like)
  threshold = 0.2,         // Min rating (m @10%)
  isLoop = false,          // Circular route?
  sign = 1,                // 1=up, -1=down, 0=both
  maxDepth = 10            // Recursion guard
} = {}) {
  if (!points?.length || points.length < 2 || maxDepth <= 0) return [];

  // Auto-compute courseDistance
  const totalDist = courseDistance || turf.length(
    { type: 'LineString', coordinates: points.map(p => [p.lon, p.lat]) },
    { units: 'kilometers' }
  );

  // Indices: simplify or full
  indices ??= simplifyPoints
    ? simplifyProfile(points, gradientPower, totalDist, isLoop)
    : points.map((_, i) => i);

  if (indices.length < 2) return [];


  // BRUTE-FORCE: Find max rating segment (O(n^2), fine post-simplify)
  let maxRating = threshold;
  let bestRange = null;
  let segPoints;
  for (let j = 1; j < indices.length; j++) {
    for (let i = 0; i < j; i++) {
      if (Math.abs(indices[j] - indices[i]) < 3) continue;  // Min 3 pts/segment
//        if ((indices[j] + 1) >= indices[i]) {
      segPoints = points.slice(indices[i], indices[j] + 1);
//        } else {
//      segPoints = points.slice(indices[j] + 1, indices[i]);
//       }
      const details = climbRating({points:segPoints}, gradientPower);
      let r = sign === 0 ? Math.abs(details.rating) : details.rating * sign;
      if (r > maxRating) {
        maxRating = r;
        bestRange = { i, j, ...details };
      }
    }
  }

  const climbs = [];
  if (bestRange && maxRating >= threshold) {
    // PREFIX recurse (before climb)
    if (bestRange.i > 0) {
      const prefixLen = turf.length(
        { type: 'LineString', coordinates: points.slice(indices[0], indices[bestRange.i] + 1).map(p => [p.lon, p.lat]) },
        { units: 'kilometers' }
      );
      climbs.push(...findClimbs({
        points,
        indices: indices.slice(0, bestRange.i),
        simplifyPoints: false,
        shiftCircuit: false,
        courseDistance: prefixLen,
        gradientPower,
        threshold,
        isLoop: false,  // Sub-segments non-loop
        sign,
        maxDepth: maxDepth - 1
      }));
    }

    // THIS CLIMB (enhanced details)
    climbs.push([indices[bestRange.i], indices[bestRange.j], {
      rating: maxRating,
      gain: bestRange.gain,
      distKm: bestRange.distKm,
      avgGrad: bestRange.avgGrad
    }]);

    // SUFFIX recurse (after climb)
    if (bestRange.j < indices.length - 1) {
      const suffixLen = turf.length(
        { type: 'LineString', coordinates: points.slice(indices[bestRange.j], indices.at(-1) + 1).map(p => [p.lon, p.lat]) },
        { units: 'kilometers' }
      );
      climbs.push(...findClimbs({
        points,
        indices: indices.slice(bestRange.j + 1),
        simplifyPoints: false,
        shiftCircuit: false,
        courseDistance: suffixLen,
        gradientPower,
        threshold,
        isLoop: false,
        sign,
        maxDepth: maxDepth - 1
      }));
    }
  }

  return climbs;
}

function climbRating({ points, gradientPower = 2 }) {
  if (points.length < 2) return 0;
  const gain = points[points.length - 1].ele - points[0].ele;
  if (gain <= 0) {
      const rating = 0;
      return { rating };
  }

  const coords = points.map(p => [p.lon, p.lat]);
  const distKm = turf.length({ type: 'LineString', coordinates: coords }, { units: 'kilometers' });  // FIXED [web:52]
  const distM = distKm * 1000;
  const avgGrad = (gain / distM) * 100;

//const rating = Math.pow(Math.max(0, gain), gradientPower) / Math.pow(10, gradientPower - 1) * Math.pow(avgGrad / 10, 1 - gradientPower);

const rating = Math.pow(Math.max(0, gain), 2) / (distM * 10);

  return { rating, gain, distKm, avgGrad };
}

function simplifyProfile(points, gradientPower, courseDistance, isLoop) {
  if (!points || points.length < 3) return points.map((_, i) => i);
  const coords = points.map(p => [p.lon, p.lat]);
  //const tolerance = (courseDistance || 50) / 1000 * Math.pow(gradientPower, 0.5) * 0.01;
  const tolerance = 0.001;
  const simplified = turf.simplify({ type: 'LineString', coordinates: coords }, { tolerance, highQuality: true });
  
  const simpIndices = [];
  simplified.coordinates.forEach(sc => {  // FIXED: geometry access [web:51]
    let minDist = Infinity, bestIdx = 0;
    coords.forEach((oc, oi) => {
      const d = turf.distance(sc, oc, { units: 'meters' });
      if (d < minDist ) { minDist = d; bestIdx = oi; }
    });
    if (minDist < 10) simpIndices.push(bestIdx);
  });
//  return isLoop ? simpIndices : circularUniq(simpIndices);
 // return circularUniq(simpIndices);
  return simpIndices;
}
        // Utils
function circularUniq(arr) {
  const uniq = [];
  for (let i = 0; i < arr.length; i++) {
    if (!uniq.includes(arr[i])) uniq.push(arr[i]);
   // if (uniq.length >= arr.length / 2) break;  // Prevent over-simplify loops
  }
  return uniq;
}
        // Parse GPX text to trackpoints array using DOMParser
        function parseGPX(gpxText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxText, 'text/xml');
            const errors = xmlDoc.getElementsByTagName('parsererror');
            if (errors.length > 0) throw new Error('Invalid GPX XML');

            const trkpts = xmlDoc.getElementsByTagName('trkpt');
            const trackpoints = [];
            for (let i = 0; i < trkpts.length; i++) {
                const pt = trkpts[i];
                const lat = parseFloat(pt.getAttribute('lat'));
                const lon = parseFloat(pt.getAttribute('lon'));
                const eleNode = pt.getElementsByTagName('ele')[0];
                const ele = eleNode ? parseFloat(eleNode.textContent) : null;
                if (!isNaN(lat) && !isNaN(lon)) {
                    trackpoints.push({ lat, lon, ele });
                }
            }
            if (trackpoints.length === 0) throw new Error('No valid trackpoints found');
            return trackpoints;
        }

        function analyzeGPX() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            const resultsDiv = document.getElementById('results');
            const errorDiv = document.getElementById('error');

            resultsDiv.style.display = 'none';
            errorDiv.style.display = 'none';

            if (!file) {
                showError('Please select a GPX file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const trackpoints = parseGPX(e.target.result);


const climbs = findClimbs({points: trackpoints, isLoop: false, threshold: 0.2});

let climbsHtml = climbs.length ? 
  climbs.map(([start, end, details]) => 
    `<tr><td>${trackpoints[start].lat},${trackpoints[start].lon} - ${trackpoints[end].lat},${trackpoints[end].lon}</td><td>${details.gain.toFixed(0)}m</td><td>${details.distKm.toFixed(1)}km</td><td>${details.avgGrad.toFixed(1)}%</td><td>${details.rating.toFixed(2)}</td></tr>`
  ).join('') : '<tr><td colspan="5">No significant climbs</td></tr>';

document.getElementById('results').innerHTML = `
  <h3>Detected Climbs (Fiets-style rating)</h3>
  <table style="width:100%; border-collapse:collapse; margin:10px 0;">
    <tr style="background:#ddd;"><th>Indices</th><th>Gain</th><th>Dist</th><th>Avg Grad</th><th>Rating</th></tr>
    ${climbsHtml}
  </table>
`;

                               resultsDiv.style.display = 'block';
 
                } catch (err) {
                    showError(err.message);
                }
            };
            reader.onerror = () => showError('Failed to read file');
            reader.readAsText(file);
        }

        function showError(msg) {
            document.getElementById('error').textContent = msg;
            document.getElementById('error').style.display = 'block';
        }
    </script>
</body>
</html>
