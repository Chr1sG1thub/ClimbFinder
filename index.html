<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX Route Analyzer</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        #fileInput { margin: 20px 0; }
        #results { margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 5px; }
        pre { background: #f4f4f4; padding: 10px; overflow-x: auto; white-space: pre-wrap; }
        button { padding: 10px 20px; background: #007cba; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #005a87; }
        .error { color: red; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <h1>GPX Route Analyzer</h1>
    <p>Select a GPX file to parse trackpoints (lat/lon/ele) and calculate route length. No external libraries needed.</p>
    <input type="file" id="fileInput" accept=".gpx" />
    <button onclick="analyzeGPX()">Analyze Route</button>
    
    <div id="results" style="display: none;">
        <h2>Results</h2>
        <p><strong>Total Length:</strong> <span id="length"></span> km</p>
        <p><strong>Trackpoints:</strong> <span id="pointCount"></span></p>
        <h3>Trackpoints Array (first 10):</h3>
        <pre id="trackpoints"></pre>
    </div>
    <div id="error" class="error" style="display: none;"></div>

    <script>

/**
 * COMPLETE JS IMPLEMENTATION: Perl findClimbs port with corrections/improvements.
 * Recursively detects climbs/descents in GPS profiles (GPX/Strava). Turf.js required.
 * Improvements: recursion guards, scaled distances, exact Fiets, efficient simplify.
 * Usage: findClimbs({points: gpxPoints, courseDistance: 50.2, isLoop: true})
 * Returns: [[startIdx, endIdx, {rating, gain, dist, avgGrad}], ...]
 * @turfjs: https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js
 */
function findClimbs({
  points,                  // [{lat, lon, ele}, ...] GPX points
  indices,                 // Optional pre-simplified indices
  simplifyPoints = true,   // Douglas-Peucker simplify?
  shiftCircuit = true,     // Rotate loops to ele min?
  courseDistance = 0,      // Total route km (auto if 0)
  gradientPower = 2,       // Steepness exponent (2=Fiets-like)
  threshold = 100,         // Min rating (m @10%)
  isLoop = false,          // Circular route?
  sign = 1,                // 1=up, -1=down, 0=both
  maxDepth = 10            // Recursion guard
} = {}) {
  if (!points?.length || points.length < 2 || maxDepth <= 0) return [];

  // Auto-compute courseDistance
  const totalDist = courseDistance || turf.lineDistance(
    { type: 'LineString', coordinates: points.map(p => [p.lon, p.lat]) },
    { units: 'kilometers' }
  );

  // Indices: simplify or full
  indices ??= simplifyPoints
    ? simplifyProfile(points, gradientPower, totalDist, isLoop)
    : points.map((_, i) => i);

  if (indices.length < 2) return [];

  // SHIFT CIRCUIT: Rotate to ele min (prevents gradient flip)
  if (shiftCircuit && isLoop) {
    let zMin = points[indices[0]].ele, izMin = 0;
    for (let i = 1; i < indices.length; i++) {
      if (points[indices[i]].ele < zMin) {
        zMin = points[indices[i]].ele;
        izMin = i;
      }
    }
    if (izMin > 0) indices = [...indices.slice(izMin), ...indices.slice(0, izMin)];
  }

  // BRUTE-FORCE: Find max rating segment (O(n^2), fine post-simplify)
  let maxRating = threshold;
  let bestRange = null;
  for (let j = 1; j < indices.length; j++) {
    for (let i = 0; i < j; i++) {
      if (indices[j] - indices[i] < 3) continue;  // Min 3 pts/segment
      const segPoints = points.slice(indices[i], indices[j] + 1);
      const details = climbRating(segPoints, gradientPower);
      let r = sign === 0 ? Math.abs(details.rating) : details.rating * sign;
      if (r > maxRating) {
        maxRating = r;
        bestRange = { i, j, ...details };
      }
    }
  }

  const climbs = [];
  if (bestRange && maxRating >= threshold) {
    // PREFIX recurse (before climb)
    if (bestRange.i > 0) {
      const prefixLen = turf.lineDistance(
        { type: 'LineString', coordinates: points.slice(indices[0], indices[bestRange.i] + 1).map(p => [p.lon, p.lat]) },
        { units: 'kilometers' }
      );
      climbs.push(...findClimbs({
        points,
        indices: indices.slice(0, bestRange.i),
        simplifyPoints: false,
        shiftCircuit: false,
        courseDistance: prefixLen,
        gradientPower,
        threshold,
        isLoop: false,  // Sub-segments non-loop
        sign,
        maxDepth: maxDepth - 1
      }));
    }

    // THIS CLIMB (enhanced details)
    climbs.push([indices[bestRange.i], indices[bestRange.j], {
      rating: maxRating,
      gain: bestRange.gain,
      distKm: bestRange.distKm,
      avgGrad: bestRange.avgGrad
    }]);

    // SUFFIX recurse (after climb)
    if (bestRange.j < indices.length - 1) {
      const suffixLen = turf.lineDistance(
        { type: 'LineString', coordinates: points.slice(indices[bestRange.j], indices.at(-1) + 1).map(p => [p.lon, p.lat]) },
        { units: 'kilometers' }
      );
      climbs.push(...findClimbs({
        points,
        indices: indices.slice(bestRange.j + 1),
        simplifyPoints: false,
        shiftCircuit: false,
        courseDistance: suffixLen,
        gradientPower,
        threshold,
        isLoop: false,
        sign,
        maxDepth: maxDepth - 1
      }));
    }
  }

  return climbs;
}

function climbRating({ points, gradientPower = 2 }) {
  if (points.length < 2) return 0;
  const gain = points[points.length - 1].ele - points[0].ele;
  if (gain <= 0) return 0;

  const coords = points.map(p => [p.lon, p.lat]);
  const distKm = turf.length({ type: 'LineString', coordinates: coords }, { units: 'kilometers' });  // FIXED [web:52]
  const distM = distKm * 1000;
  const pctGrad = (gain / distM) * 100;

  return Math.pow(Math.max(0, gain), gradientPower) / Math.pow(10, gradientPower - 1) * Math.pow(pctGrad / 10, 1 - gradientPower);
}

function simplifyProfile(points, gradientPower, courseDistance, isLoop) {
  if (!points || points.length < 3) return points.map((_, i) => i);
  const coords = points.map(p => [p.lon, p.lat]);
  const tolerance = (courseDistance || 50) / 1000 * Math.pow(gradientPower, 0.5) * 0.01;
  const simplified = turf.simplify({ type: 'LineString', coordinates: coords }, { tolerance, highQuality: false });
  
  const simpIndices = [];
  simplified.geometry.coordinates.forEach(sc => {  // FIXED: geometry access [web:51]
    let minDist = Infinity, bestIdx = 0;
    coords.forEach((oc, oi) => {
      const d = turf.distance(sc, oc, { units: 'meters' });
      if (d < minDist) { minDist = d; bestIdx = oi; }
    });
    if (minDist < 10) simpIndices.push(bestIdx);
  });
  return isLoop ? simpIndices : uniq(simpIndices);
}
        // Utils
function circularUniq(arr) {
  const uniq = [];
  for (let i = 0; i < arr.length; i++) {
    if (!uniq.includes(arr[i])) uniq.push(arr[i]);
    if (uniq.length >= arr.length / 2) break;  // Prevent over-simplify loops
  }
  return uniq;
}

        // Haversine distance between two points (km)
        function haversineDistance(p1, p2) {
            const R = 6371;
            const dLat = (p2.lat - p1.lat) * Math.PI / 180;
            const dLon = (p2.lon - p1.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2)**2 + Math.cos(p1.lat * Math.PI/180) * Math.cos(p2.lat * Math.PI/180) * Math.sin(dLon/2)**2;
            return R * 2 * Math.asin(Math.sqrt(a));
        }

        // Parse GPX text to trackpoints array using DOMParser
        function parseGPX(gpxText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxText, 'text/xml');
            const errors = xmlDoc.getElementsByTagName('parsererror');
            if (errors.length > 0) throw new Error('Invalid GPX XML');

            const trkpts = xmlDoc.getElementsByTagName('trkpt');
            const trackpoints = [];
            for (let i = 0; i < trkpts.length; i++) {
                const pt = trkpts[i];
                const lat = parseFloat(pt.getAttribute('lat'));
                const lon = parseFloat(pt.getAttribute('lon'));
                const eleNode = pt.getElementsByTagName('ele')[0];
                const ele = eleNode ? parseFloat(eleNode.textContent) : null;
                if (!isNaN(lat) && !isNaN(lon)) {
                    trackpoints.push({ lat, lon, ele });
                }
            }
            if (trackpoints.length === 0) throw new Error('No valid trackpoints found');
            return trackpoints;
        }

        function analyzeGPX() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            const resultsDiv = document.getElementById('results');
            const errorDiv = document.getElementById('error');

            resultsDiv.style.display = 'none';
            errorDiv.style.display = 'none';

            if (!file) {
                showError('Please select a GPX file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const trackpoints = parseGPX(e.target.result);


const climbs = findClimbs({points: trackpoints});


                    

                    // Calculate total length
                    let totalLength = 0;
                    for (let i = 1; i < trackpoints.length; i++) {
                        totalLength += haversineDistance(trackpoints[i-1], trackpoints[i]);
                    }

                    // Display
                    document.getElementById('length').textContent = totalLength.toFixed(2);
                    document.getElementById('pointCount').textContent = trackpoints.length.toLocaleString();
                    document.getElementById('trackpoints').textContent = JSON.stringify(
                        trackpoints.slice(0, 10), null, 2
                    );
                    resultsDiv.style.display = 'block';
                } catch (err) {
                    showError(err.message);
                }
            };
            reader.onerror = () => showError('Failed to read file');
            reader.readAsText(file);
        }

        function showError(msg) {
            document.getElementById('error').textContent = msg;
            document.getElementById('error').style.display = 'block';
        }
    </script>
</body>
</html>
