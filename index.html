<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climb Finder</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        #fileInput { margin: 20px 0; }
        #results { margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 5px; }
        pre { background: #f4f4f4; padding: 10px; overflow-x: auto; white-space: pre-wrap; }
        button { padding: 10px 20px; background: #007cba; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #005a87; }
        .error { color: red; }
    </style>
</head>
<body>
    <h1>Climb Finder</h1>
    <p>Select a GPX file to parse trackpoints (lat/lon/ele) and calculate route length. No external libraries needed.</p>
    <input type="file" id="fileInput" accept=".gpx" />
    <button onclick="analyzeGPX()">Analyze Route</button>
    
    <div id="results" style="display: none;">
        <h2>Results</h2>
        <p><strong>Total Length:</strong> <span id="length"></span> km</p>
        <p><strong>Trackpoints:</strong> <span id="pointCount"></span></p>
        <h3>Trackpoints Array (first 10):</h3>
        <pre id="trackpoints"></pre>
    </div>
    <div id="error" class="error" style="display: none;"></div>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf@7.3.1/turf.min.js"></script>
    <script>

/**
 * Full JS port of Perl findClimbs: Recursively finds climb/descent segments in GPS elevation profile.
 * Uses Turf.js for distances, Fiets-like rating. Assumes points: [{lat, lon, ele}, ...]
 * @returns Array of [[startIdx, endIdx], ...] pairs of ORIGINAL point indices.
 */
function findClimbs({
  points,                  // [{lat, lon, ele}, ...]
  indices,                 // Optional pre-computed indices
  simplifyPoints = true,   // Use simplifyProfile?
  shiftCircuit = true,     // Shift loops to ele min?
  courseDistance,          // Total route km (used in simplify/normalize)
  gradientPower = 2,       // Exponent for steepness bias
  threshold = 100,         // Min Fiets rating (m @10%)
  isLoop = false,          // Circular route?
  sign = 1                 // 1=climbs, -1=descents, 0=both (abs)
}) {
  if (!points || points.length < 2) return [];

  // Compute indices if not provided
  indices = indices || (simplifyPoints ? simplifyProfile(points, gradientPower, courseDistance, isLoop) : points.map((_, i) => i));

  // Shift circuit to ele min (no gradient flips across bottom)
  if (shiftCircuit && isLoop && indices.length > 1) {
    let zMin = points[indices[0]].ele;
    let izMin = 0;
    for (let i = 1; i < indices.length; i++) {
      if (points[indices[i]].ele < zMin) {
        zMin = points[indices[i]].ele;
        izMin = i;
      }
    }
    if (izMin > 0) {
      indices = indices.slice(izMin).concat(indices.slice(0, izMin));
    }
  }

  // Brute-force find max Fiets rating segment
  let rating = threshold;
  let range = null;
  for (let j = 1; j < indices.length; j++) {
    for (let i = 0; i < j; i++) {
      const segPoints = points.slice(indices[i], indices[j] + 1);
      let r = climbRating({ points: segPoints, gradientPower });
      if (sign === 0) r = Math.abs(r);
      else r *= sign;
      if (r > rating) {
        rating = r;
        range = [i, j];
      }
    }
  }

  const climbs = [];
  if (range && rating >= threshold) {
    // Recurse prefix
    if (range[0] > 0) {
      climbs.push(...findClimbs({
        points,
        indices: indices.slice(0, range[0]),
        simplifyPoints: false,
        shiftCircuit: false,
        courseDistance,
        gradientPower,
        threshold,
        isLoop,
        sign
      }));
    }

    // Add this climb (original indices)
    climbs.push([indices[range[0]], indices[range[1]]]);

    // Recurse suffix
    if (range[1] < indices.length - 1) {
      climbs.push(...findClimbs({
        points,
        indices: indices.slice(range[1] + 1),
        simplifyPoints: false,
        shiftCircuit: false,
        courseDistance,
        gradientPower,
        threshold,
        isLoop,
        sign
      }));
    }
  }

  return climbs;
}

/**
 * Fiets climb rating: Normalized "vertical meters @10%". Penalizes shallow gradients.
 * Approx: (gain^gp / dist) * (10% norm factor)
 */
function climbRating({ points, gradientPower = 2 }) {
  if (points.length < 2) return 0;
  const gain = points[points.length - 1].ele - points[0].ele;
  if (gain <= 0) return 0;  // Climbs only (modify for descents)


  const coords = points.map(p => [p.lon, p.lat]);
  const distKm = turf.lineDistance({ type: 'LineString', coordinates: coords }, { units: 'kilometers' });
  const distM = distKm * 1000;
  const pctGrad = (gain / distM) * 100;

  // Fiets-like: gain * (pctGrad / 10)^(1-gp) approx, but gp-power on gain for steep bias [web:16]
  return Math.pow(Math.max(0, gain), gradientPower) / Math.pow(10, gradientPower - 1) * Math.pow(pctGrad / 10, 1 - gradientPower);
}

/**
 * simplifyProfile stub: Douglas-Peucker via Turf (tolerance based on courseDistance/gradientPower).
 * Returns key indices preserving profile shape.
 */
function simplifyProfile(points, gradientPower, courseDistance, isLoop) {
  if (!points || points.length < 3) return points.map((_, i) => i);
  const coords = points.map(p => [p.lon, p.lat]);
  const tolerance = (courseDistance || 50) / 1000 * Math.pow(gradientPower, 0.5) * 0.01;  // Adaptive ~1% route
  const simplified = turf.simplify({ type: 'LineString', coordinates: coords }, { tolerance, highQuality: false });
  const simpIndices = [];  // Map back to original indices (approx via closest coord match)
  simplified.coordinates.forEach(sc => {
    let minDist = Infinity, bestIdx = 0;
    coords.forEach((oc, oi) => {
      const d = turf.distance(sc, oc, { units: 'meters' });
      if (d < minDist) { minDist = d; bestIdx = oi; }
    });
    if (minDist < 10) simpIndices.push(bestIdx);  // Threshold match
  });
  return isLoop ? simpIndices : uniq(simpIndices);  // Dedup
}

// Helpers
function uniq(arr) {
  return arr.filter((v, i, a) => a.indexOf(v) === i);
}

        
        // Haversine distance between two points (km)
        function haversineDistance(p1, p2) {
            const R = 6371;
            const dLat = (p2.lat - p1.lat) * Math.PI / 180;
            const dLon = (p2.lon - p1.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2)**2 + Math.cos(p1.lat * Math.PI/180) * Math.cos(p2.lat * Math.PI/180) * Math.sin(dLon/2)**2;
            return R * 2 * Math.asin(Math.sqrt(a));
        }

        // Parse GPX text to trackpoints array using DOMParser
        function parseGPX(gpxText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxText, 'text/xml');
            const errors = xmlDoc.getElementsByTagName('parsererror');
            if (errors.length > 0) throw new Error('Invalid GPX XML');

            const trkpts = xmlDoc.getElementsByTagName('trkpt');
            const trackpoints = [];
            for (let i = 0; i < trkpts.length; i++) {
                const pt = trkpts[i];
                const lat = parseFloat(pt.getAttribute('lat'));
                const lon = parseFloat(pt.getAttribute('lon'));
                const eleNode = pt.getElementsByTagName('ele')[0];
                const ele = eleNode ? parseFloat(eleNode.textContent) : null;
                if (!isNaN(lat) && !isNaN(lon)) {
                    trackpoints.push({ lat, lon, ele });
                }
            }
            if (trackpoints.length === 0) throw new Error('No valid trackpoints found');
            return trackpoints;
        }

        function analyzeGPX() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            const resultsDiv = document.getElementById('results');
            const errorDiv = document.getElementById('error');

            resultsDiv.style.display = 'none';
            errorDiv.style.display = 'none';

            if (!file) {
                showError('Please select a GPX file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const trackpoints = parseGPX(e.target.result);

                    // Calculate total length
                    let totalLength = 0;
                    for (let i = 1; i < trackpoints.length; i++) {
                        totalLength += haversineDistance(trackpoints[i-1], trackpoints[i]);
                    }

                    // Display
                    document.getElementById('length').textContent = totalLength.toFixed(2);
                    document.getElementById('pointCount').textContent = trackpoints.length.toLocaleString();
                    document.getElementById('trackpoints').textContent = JSON.stringify(
                        trackpoints.slice(0, 10), null, 2
                    );
                    resultsDiv.style.display = 'block';
                } catch (err) {
                    showError(err.message);
                }
            };
            reader.onerror = () => showError('Failed to read file');
            reader.readAsText(file);
        }

        function showError(msg) {
            document.getElementById('error').textContent = msg;
            document.getElementById('error').style.display = 'block';
        }
    </script>
</body>
</html>
